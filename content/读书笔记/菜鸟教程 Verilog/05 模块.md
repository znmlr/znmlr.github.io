---
title: "05 模块"
date: 2022-09-27T17:00:02+08:00
draft: false
weight: 5
---

## 5.1 模块与端口

- 结构建模方式有 `3` 类描述语句： `Gate`（门级）例化语句，`UDP` (用户定义原语)例化语句和 `module` (模块) 例化语句。本次主要讲述使用最多的模块级例化语句。

### 5.1.1 模块

- 模块是 `Verilog` 中基本单元的定义形式，是与外界交互的接口。

```verilog
module module_name 
#(parameter_list)
(port_list) ;
              Declarations_and_Statements ;
endmodule
```

- 模块定义必须以关键字 `module` 开始，以关键字 `endmodule` 结束。

  ![img](http://nas.znmlr.cn:15900/markdown/2022/09/jxRkciGWpiEbvz3D.png)

### 5.1.2 端口

- 端口是模块与外界交互的接口。对于外部环境来说，模块内部是不可见的，对模块的调用只能通过端口连接进行。
- 模块的定义中包含一个可选的端口列表，一般将不带类型、不带位宽的信号变量罗列在模块声明里。下面是一个 `PAD` 模型的端口列表：

```verilog
module pad(
    DIN, OEN, PULL,
    DOUT, PAD);
```

- 一个模块如果和外部环境没有交互，则可以不用声明端口列表
- 端口信号在端口列表中罗列出来以后，就可以在模块实体中进行声明了。根据端口的方向，端口类型有 3 种： 输入`input`，输出`output`和双向端口`inout`。
- `input`、`inout` 类型不能声明为 `reg` 数据类型，因为 `reg` 类型是用于保存数值的，而输入端口只能反映与其相连的外部信号的变化，不能保存这些信号的值。
- `output` 可以声明为 `wire` 或 `reg` 数据类型。

```verilog
//端口类型声明
input        DIN, OEN ;
input [1:0]  PULL ;  //(00,01-dispull, 11-pullup, 10-pulldown)
inout        PAD ;   //pad value
output       DOUT ;  //pad load when pad configured as input

//端口数据类型声明
wire         DIN, OEN ;
wire  [1:0]  PULL ;
wire         PAD ;
reg          DOUT ;
```

- 端口隐式的声明为 `wire` 型变量，即当端口具有 `wire` 属性时，不用再次声明端口类型为 `wire` 型。但是，当端口有 `reg` 属性时，则 `reg` 声明不可省略。

```verilog
//端口类型声明，可以简化为
input        DIN, OEN ;
input [1:0]  PULL ;    
inout        PAD ;    
output       DOUT ;    
reg          DOUT ;

//信号 DOUT 的声明完全可以合并成一句
output reg      DOUT ;
```

```verilog
module pad(
    input        DIN, OEN ,
    input [1:0]  PULL ,
    inout        PAD ,
    output reg   DOUT
    );
// 等价于
module pad(
    input        DIN, OEN ,
    input [1:0]  PULL ,
    inout        PAD ,
    output       DOUT
    );
 
    reg        DOUT ;
```

## 5.2 模块例化

- 在一个模块中引用另一个模块，对其端口进行相关连接，叫做模块例化。模块例化建立了描述的层次。信号端口可以通过位置或名称关联，端口连接也必须遵循一些规则。

### 5.2.1 命名端口连接

- 将需要例化的模块端口与外部信号按照其名字进行连接，端口顺序随意，可以与引用 module 的声明端口顺序不一致，只要保证端口名字与外部信号匹配即可。

```verilog
// 例化一次 1bit 全加器的例子

full_adder1  u_adder0(
    .Ai     (a[0]),
    .Bi     (b[0]),
    .Ci     (c==1'b1 ? 1'b0 : 1'b1),
    .So     (so_bit0),
    .Co     (co_temp[0]));

//output 端口 Co 悬空
full_adder1  u_adder0(
    .Ai     (a[0]),
    .Bi     (b[0]),
    .Ci     (c==1'b1 ? 1'b0 : 1'b1),
    .So     (so_bit0),
    .Co     ());
 
//output 端口 Co 删除
full_adder1  u_adder0(
    .Ai     (a[0]),
    .Bi     (b[0]),
    .Ci     (c==1'b1 ? 1'b0 : 1'b1),
    .So     (so_bit0));
```

- 如果某些输出端口并不需要在外部连接，例化时 可以悬空不连接，甚至删除。一般来说，`input` 端口在例化时不能删除，否则编译报错，`output` 端口在例化时可以删除。

### 5.2.2 顺序端口例化

- 这种方法将需要例化的模块端口按照模块声明时端口的顺序与外部信号进行匹配连接，位置要严格保持一致。
- 例如例化一次 1bit 全加器的代码可以改为：

```verilog
full_adder1  u_adder1(
    a[1], b[1], co_temp[0], so_bit1, co_temp[1]);
```

- 虽然代码从书写上可能会占用相对较少的空间，但代码可读性降低，也不易于调试。
- 有时候在大型的设计中可能会有很多个端口，端口信号的顺序时不时的可能也会有所改动，
- 此时再利用顺序端口连接进行模块例化，显然是不方便的。所以平时，建议采用命名端口方式对模块进行例化。

### 5.2.3 端口连接规则

- **输入端口**

模块例化时，从模块外部来讲， `input` 端口可以连接 `wire` 或 `reg` 型变量。这与模块声明是不同的，从模块内部来讲，`input` 端口必须是 `wire` 型变量。

- **输出端口**

模块例化时，从模块外部来讲，`output` 端口必须连接 `wire` 型变量。这与模块声明是不同的，从模块内部来讲，`output` 端口可以是 `wire` 或 `reg` 型变量。

- **输入输出端口**

模块例化时，从模块外部来讲，`inout` 端口必须连接 `wire` 型变量。这与模块声明是相同的。

- **悬空端口**

模块例化时，如果某些信号不需要与外部信号进行连接交互，我们可以将其悬空，即端口例化处保留空白即可，上述例子中有提及。`output` 端口正常悬空时，我们甚至可以在例化时将其删除。`input` 端口正常悬空时，悬空信号的逻辑功能表现为高阻状态（逻辑值为 `z`）。但是，例化时一般不能将悬空的 `input` 端口删除，否则编译会报错

```verilog
//下述代码编译会报Warning
full_adder4  u_adder4(
    .a      (a),
    .b      (b),
    .c      (),
    .so     (so),
    .co     (co));
    
//如果模块full_adder4有input端口c，则下述代码编译是会报Error
full_adder4  u_adder4(
    .a      (a),
    .b      (b),
    .so     (so),
    .co     (co));
    
//建议 input 端口不要做悬空处理，无其他外部连接时赋值其常量
full_adder4  u_adder4(
    .a      (a),
    .b      (b),
    .c      (1'b0),
    .so     (so),
    .co     (co));
```

- **位宽匹配**

当例化端口与连续信号位宽不匹配时，端口会通过无符号数的右对齐或截断方式进行匹配

```verilog
// 下面代码的例化结果会导致：u_adder4.a = {2'bzz, a[1:0]}, u_adder4.b = b[3:0] 
full_adder4  u_adder4(
    .a      (a[1:0]),      //input a[3:0]
    .b      (b[5:0]),      //input b[3:0]
    .c      (1'b0),
    .so     (so),
    .co     (co));
```

### 5.2.4 用 `generate` 进行模块例化

- 当例化多个相同的模块时，一个一个的手动例化会比较繁琐。用 `generate` 语句进行多个模块的重复例化，可大大简化程序的编写过程。

```verilog
module full_adder4(
    input [3:0]   a ,   //adder1
    input [3:0]   b ,   //adder2
    input         c ,   //input carry bit
 
    output [3:0]  so ,  //adding result
    output        co    //output carry bit
    );
 
    wire [3:0]    co_temp ;
    //第一个例化模块一般格式有所差异，需要单独例化
    full_adder1  u_adder0(
        .Ai     (a[0]),
        .Bi     (b[0]),
        .Ci     (c==1'b1 ? 1'b1 : 1'b0),
        .So     (so[0]),
        .Co     (co_temp[0]));
 
    genvar        i ;
    generate
        for(i=1; i<=3; i=i+1) begin: adder_gen
        full_adder1  u_adder(
            .Ai     (a[i]),
            .Bi     (b[i]),
            .Ci     (co_temp[i-1]), //上一个全加器的溢位是下一个的进位
            .So     (so[i]),
            .Co     (co_temp[i]));
        end
    endgenerate
 
    assign co    = co_temp[3] ;
 
endmodule

// testbench 如下：
`timescale 1ns/1ns
 
module test ;
    reg  [3:0]   a ;
    reg  [3:0]   b ;
    //reg          c ;
    wire [3:0]   so ;
    wire         co ;
 
    //简单驱动
    initial begin
        a = 4'd5 ;
        b = 4'd2 ;
        #10 ;
        a = 4'd10 ;
        b = 4'd8 ;
    end
 
    full_adder4  u_adder4(
               .a      (a),
               .b      (b),
               .c      (1'b0),   //端口可以连接常量
               .so     (so),
               .co     (co));
 
    initial begin
        forever begin
            #100;
            if ($time >= 1000)  $finish ;
        end
    end
 
endmodule // test
```

### 5.2.5 层次访问

- 每一个例化模块的名字，每个模块的信号变量等，都使用一个特定的标识符进行定义。在整个层次设计中，每个标识符都具有唯一的位置与名字。

- `Verilog` 中，通过使用一连串的 **.** 符号对各个模块的标识符进行层次分隔连接，就可以在任何地方通过指定完整的层次名对整个设计中的标识符进行访问。

  ![img](http://nas.znmlr.cn:15900/markdown/2022/09/4EEC5MktHZA7Y0sq.png)

## 5.3 带参数实例化

- 当一个模块被另一个模块引用例化时，高层模块可以对低层模块的参数值进行改写。这样就允许在编译时将不同的参数传递给多个相同名字的模块，而不用单独为只有参数不同的多个模块再新建文件。
- 参数覆盖有 2 种方式：使用关键字 `defparam`，带参数值模块例化。

### 5.3.1 `defparam`语句

- 可以用关键字 `defparam` 通过模块层次调用的方法，来改写低层次模块的参数值。

```verilog
// 例如对一个单口地址线和数据线都是 4bit 宽度的 ram 模块的 MASK 参数进行改写：

//instantiation
defparam     u_ram_4x4.MASK = 7 ;
ram_4x4    u_ram_4x4
    (
        .CLK    (clk),
        .A      (a[4-1:0]),
        .D      (d),
        .EN     (en),
        .WR     (wr),    //1 for write and 0 for read
        .Q      (q)    );
        
// ram_4x4 的模型如下：
module  ram_4x4
    (
     input               CLK ,
     input [4-1:0]       A ,
     input [4-1:0]       D ,
     input               EN ,
     input               WR ,    //1 for write and 0 for read
     output reg [4-1:0]  Q    );
 
    parameter        MASK = 3 ;
 
    reg [4-1:0]     mem [0:(1<<4)-1] ;
    always @(posedge CLK) begin
        if (EN && WR) begin
            mem[A]  <= D & MASK;
        end
        else if (EN && !WR) begin
            Q       <= mem[A] & MASK;
        end
    end
 
endmodule

// testbench 编写如下：
`timescale 1ns/1ns
 
module test ;
    parameter    AW = 4 ;
    parameter    DW = 4 ;
 
    reg                  clk ;
    reg [AW:0]           a ;
    reg [DW-1:0]         d ;
    reg                  en ;
    reg                  wr ;
    wire [DW-1:0]        q ;
 
    //clock generating
    always begin
        #15 ;     clk = 0 ;
        #15 ;     clk = 1 ;
    end
 
    initial begin
        a         = 10 ;
        d         = 2 ;
        en        = 'b0 ;
        wr        = 'b0 ;
        repeat(10) begin
            @(negedge clk) ;
            en     = 1'b1;
            a      = a + 1 ;
            wr     = 1'b1 ;  //write command
            d      = d + 1 ;
        end
        a         = 10 ;
        repeat(10) begin
            @(negedge clk) ;
            a      = a + 1 ;
            wr     = 1'b0 ;  //read command
        end
    end // initial begin
 
    //instantiation
    defparam     u_ram_4x4.MASK = 7 ;
    ram_4x4    u_ram_4x4
    (
        .CLK    (clk),
        .A      (a[AW-1:0]),
        .D      (d),
        .EN     (en),
        .WR     (wr),    //1 for write and 0 for read
        .Q      (q)
     );
 
    //stop simulation
    initial begin
        forever begin
            #100;
            if ($time >= 1000)  $finish ;
        end
    end
 
endmodule // test
```

### 5.3.2 带参数模块例化

- 第二种方法就是例化模块时，将新的参数值写入模块例化语句，以此来改写原有 `module` 的参数值。

```verilog
// 对一个地址和数据位宽都可变的 ram 模块进行带参数的模块例化：
ram #(.AW(4), .DW(4))
    u_ram
    (
        .CLK    (clk),
        .A      (a[AW-1:0]),
        .D      (d),
        .EN     (en),
        .WR     (wr),    //1 for write and 0 for read
        .Q      (q)
     );
// ram 模型如下：
module  ram
    #(  parameter       AW = 2 ,
        parameter       DW = 3 )
    (
        input                   CLK ,
        input [AW-1:0]          A ,
        input [DW-1:0]          D ,
        input                   EN ,
        input                   WR ,    //1 for write and 0 for read
        output reg [DW-1:0]     Q
     );
 
    reg [DW-1:0]         mem [0:(1<<AW)-1] ;
    always @(posedge CLK) begin
        if (EN && WR) begin
            mem[A]  <= D ;
        end
        else if (EN && !WR) begin
            Q       <= mem[A] ;
        end
    end
 
endmodule

// 仿真时，只需在上一例的 testbench 中，将本次例化的模块 u_ram 覆盖掉 u_ram_4x4, 或重新添加之即可。
```
