---
title: "03 赋值与时延"
date: 2022-09-27T16:31:52+08:00
draft: false
weight: 3
---

## 3.1 赋值

- 连续赋值语句是 `Verilog` 数据流建模的基本语句，用于对 `wire` 型变量进行赋值。：
- `assign` 为关键词，任何已经声明 `wire` 变量的连续赋值语句都是以 `assign` 开头，例如：

```verilog
wire      Cout, A, B ;
assign    Cout  = A & B ;     //实现计算A与B的功能
```

- 左值必须是一个标量或者线型向量，而不能是寄存器类型。
- 右值的类型没有要求，可以是标量或线型或存器向量，也可以是函数调用。
- 只要右值表达式的操作数有事件发生（值的变化）时，右值表达式就会立刻重新计算，同时赋值给左值。

- `Verilog` 还提供了另一种对 `wire` 型赋值的简单方法，即在 `wire` 型变量声明的时候同时对其赋值。`wire` 型变量只能被赋值一次，因此该种连续赋值方式也只能有一次。例如下面赋值方式和上面的赋值例子的赋值方式，效果都是一致的。

```verilog
wire      A, B ;
wire      Cout = A & B ;
```

## 3.2 全加器

- 设 `Ai`，`Bi`，`Ci` 分别为被加数、加数和相邻低位的进位数，`So`, `Co` 分别为本位和与向相邻高位的进位数。

    ![Snipaste_2022-09-17_11-32-52](http://nas.znmlr.cn:15900/markdown/2022/09/Snipaste_2022-09-17_11-32-52.png)

```verilog
module full_adder1(
    input    Ai, Bi, Ci,
    output   So, Co);
 
    assign So = Ai ^ Bi ^ Ci ;
    assign Co = (Ai & Bi) | (Ci & (Ai | Bi));
endmodule
// 更为贴近加法器的代码描述可以为
module full_adder1(
    input    Ai, Bi, Ci
    output   So, Co);
 
    assign {Co, So} = Ai + Bi + Ci ;
endmodule
```

## 3.3 时延

- 连续赋值延时语句中的延时，用于控制任意操作数发生变化到语句左端赋予新值之间的时间延时。

- 时延一般是不可综合的。连续赋值时延一般可分为普通赋值时延、隐式时延、声明时延。

```verilog
//普通时延，A&B计算结果延时10个时间单位赋值给Z
wire Z, A, B ;
assign #10    Z = A & B ;

//隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。
wire A, B;
wire #10        Z = A & B;

//声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。
wire A, B;
wire #10 Z ;
assign           Z =A & B
```

### 3.3.1 惯性时延

- 在上述例子中，`A` 或 `B` 任意一个变量发生变化，那么在 `Z` 得到新的值之前，会有 `10` 个时间单位的时延。如果在这 `10` 个时间单位内，即在 `Z` 获取新的值之前，`A` 或 `B` 任意一个值又发生了变化，那么计算 `Z` 的新值时会取 `A` 或 `B` 当前的新值。所以称之为惯性时延，即信号脉冲宽度小于时延时，对输出没有影响。
