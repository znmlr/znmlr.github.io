---
title: "06 函数"
date: 2022-09-27T17:00:36+08:00
draft: false
weight: 6
---

## 6.1 函数

- 在 `Verilog` 中，可以利用任务（关键字为 `task`）或函数（关键字为 `function`），将重复性的行为级设计进行提取，并在多个地方调用，来避免重复代码的多次编写，使代码更加的简洁、易懂。
- 函数只能在模块中定义，位置任意，并在模块的任何地方引用，作用范围也局限于此模块。函数主要有以下几个特点： 
  - 1、不含有任何延迟、时序或时序控制逻辑
  - 2、至少有一个输入变量
  - 3、只有一个返回值，且没有输出
  - 4、不含有非阻塞赋值语句
  - 5、函数可以调用其他函数，但是不能调用任务
  
  ```verilog
  function [range-1:0]     function_id ;
  input_declaration ;
   other_declaration ;
  procedural_statement ;
  endfunction
  ```

- 函数在声明时，会隐式的声明一个宽度为 `range`、 名字为 `function_id` 的寄存器变量，函数的返回值通过这个变量进行传递。当该寄存器变量没有指定位宽时，默认位宽为 `1`。
- 函数通过指明函数名与输入变量进行调用。函数结束时，返回值被传递到调用处。

```verilog
module endian_rvs
    #(parameter N = 4)
        (
            input             en,     //enable control
            input [N-1:0]     a ,
            output [N-1:0]    b
    );
         
	reg [N-1:0]          b_temp ;
    always @(*) begin
    	if (en) begin
        	b_temp =  data_rvs(a);
        end
        else begin
        	b_temp = 0 ;
        end
    end
    assign b = b_temp ;
         
    //function entity
    function [N-1:0]     data_rvs ;
    	input     [N-1:0] data_in ;
        parameter         MASK = 32'h3 ;
        integer           k ;
        begin
        	for(k=0; k<N; k=k+1) begin
            	data_rvs[N-k-1]  = data_in[k] ;  
            end
        end
	endfunction      
endmodule   

// 函数在声明时，也可以在函数名后面加一个括号，将 input 声明包起来。
function [N-1:0]     data_rvs（
	input     [N-1:0] data_in 
    ......
    ）;
```

### 6.1.1 常数函数

- 常数函数是指在仿真开始之前，在编译期间就计算出结果为常数的函数。常数函数不允许访问全局变量或者调用系统函数，但是可以调用另一个常数函数。
- 这种函数能够用来引用复杂的值，因此可用来代替常量。

```verilog
parameter    MEM_DEPTH = 256 ;
reg  [logb2(MEM_DEPTH)-1: 0] addr ; //可得addr的宽度为8bit
 
    function integer     logb2;
    	input integer     depth ;
        	//256为9bit，我们最终数据应该是8，所以需depth=2时提前停止循环
    	for(logb2=0; depth>1; logb2=logb2+1) begin
        	depth = depth >> 1 ;
    	end
	endfunction
```

### 6.1.2 `automatic` 函数

- 在 `Verilog` 中，一般函数的局部变量是静态的，即函数的每次调用，函数的局部变量都会使用同一个存储空间。若某个函数在两个不同的地方同时并发的调用，那么两个函数调用行为同时对同一块地址进行操作，会导致不确定的函数结果。
- `Verilog` 用关键字 `automatic` 来对函数进行说明，此类函数在调用时是可以自动分配新的内存空间的，也可以理解为是可递归的。因此，`automatic` 函数中声明的局部变量不能通过层次命名进行访问，但是 `automatic` 函数本身可以通过层次名进行调用。

```verilog
wire [31:0]          results3 = factorial(4);
function automatic   integer         factorial ;
    input integer     data ;
    integer           i ;
    begin
        factorial = (data>=2)? data * factorial(data-1) : 1 ;
    end
endfunction // factorial
```

6.2 任务

- 和函数一样，任务`task`可以用来描述共同的代码段，并在模块内任意位置被调用，让代码更加的直观易读。函数一般用于组合逻辑的各种转换和计算，而任务更像一个过程，不仅能完成函数的功能，还可以包含时序控制逻辑。下面对任务与函数的区别进行概括：

    ![Snipaste_2022-09-18_09-46-40](http://nas.znmlr.cn:15900/markdown/2022/09/Snipaste_2022-09-18_09-46-40.png)

### 6.2.1 任务声明

任务在模块中任意位置定义，并在模块内任意位置引用，作用范围也局限于此模块。

模块内子程序出现下面任意一个条件时，则必须使用任务而不能使用函数。

- 1、子程序中包含时序控制逻辑，例如延迟，事件控制等
- 2、没有输入变量
- 3、没有输出或输出端的数量大于 1

```verilog
task       task_id ;
    port_declaration ;
    procedural_statement ;
endtask
```

- 任务中使用关键字 `input`、`output` 和 `inout` 对端口进行声明。`input` 、`inout` 型端口将变量从任务外部传递到内部，`output`、`inout` 型端口将任务执行完毕时的结果传回到外部。

- 进行任务的逻辑设计时，可以把 `input` 声明的端口变量看做 `wire` 型，把 `output` 声明的端口变量看做 `reg` 型。但是不需要用 `reg` 对 `output` 端口再次说明。

- 对 `output` 信号赋值时也不要用关键字 `assign`。为避免时序错乱，建议 `output` 信号采用阻塞赋值。

```verilog
task xor_oper_iner;
    input [N-1:0]   numa;
    input [N-1:0]   numb;
    output [N-1:0]  numco ;
    //output reg [N-1:0]  numco ; //无需再注明 reg 类型，虽然注明也可能没错
    #3  numco = numa ^ numb ;
    //assign #3 numco = numa ^ numb ; //不用assign，因为输出默认是reg
endtask

// 任务在声明时，也可以在任务名后面加一个括号，将端口声明包起来。
task xor_oper_iner（
    input [N-1:0]   numa,
    input [N-1:0]   numb,
    output [N-1:0]  numco  ） ;
    #3  numco       = numa ^ numb ;
endtask
```

### 6.2.2 任务调用

- 任务可单独作为一条语句出现在 `initial` 或 `always` 块中，调用格式如下：

```verilog
task_id(input1, input2, …,outpu1, output2, …);
```

- 任务调用时，端口必须按顺序对应。

- 输入端连接的模块内信号可以是 `wire` 型，也可以是 `reg` 型。输出端连接的模块内信号要求一定是 `reg` 型

### 6.2.3 任务操作全局变量

- 任务可以看做是过程性赋值，所以任务的 `output` 端信号返回时间是在任务中所有语句执行完毕之后
- 任务内部变量也只有在任务中可见，如果想具体观察任务中对变量的操作过程，需要将观察的变量声明在模块之内、任务之外，可谓之`全局变量`

```verilog
//way1 to decirbe clk generating, not work
task clk_rvs_iner ;
        output    clk_no_rvs ;
        # 5 ;     clk_no_rvs = 0 ;
        # 5 ;     clk_no_rvs = 1 ;
endtask
reg          clk_test1 ;
always clk_rvs_iner(clk_test1);

//way2: use task to operate global varialbes to generating clk
reg          clk_test2 ;
task clk_rvs_global ;
        # 5 ;     clk_test2 = 0 ;
        # 5 ;     clk_test2 = 1 ;
endtask // clk_rvs_iner
always clk_rvs_global;
```

- 第一种描述方式，虽然任务内部变量会有赋值 `0` 和赋值 `1` 的过程操作，但中间变化过程并不可见，最后输出的结果只能是任务内所有语句执行完毕后输出端信号的最终值。所以信号 `clk_test1` 值恒为 `1`，此种方式产生不了时钟。

- 第二种描述方式，虽然没有端口信号，但是直接对`全局变量`进行过程操作，因为该全局变量对模块是可见的，所以任务内信号翻转的过程会在信号`clk_test2`中体现出来。

### 6.2.4 `automatic `任务

- 和函数一样，`Verilog` 中任务调用时的局部变量都是静态的。可以用关键字 `automatic` 来对任务进行声明，那么任务调用时各存储空间就可以动态分配，每个调用的任务都各自独立的对自己独有的地址空间进行操作，而不影响多个相同任务调用时的并发执行。
- 如果一任务代码段被 `2` 处及以上调用，一定要用关键字 `automatic` 声明。

## 6.3 状态机

- 有限状态机（`Finite-State Machine`，`FSM`），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。状态机不仅是一种电路的描述工具，而且也是一种思想方法，在电路设计的系统级和 `RTL` 级有着广泛的应用。
- `Verilog` 中状态机主要用于同步时序逻辑的设计，能够在有限个状态之间按一定要求和规律切换时序电路的状态。状态的切换方向不但取决于各个输入值，还取决于当前所在状态。 状态机可分为 `2` 类：`Moore` 状态机和 `Mealy` 状态机。

### 6.3.1 `Moore` 型状态机

- `Moore` 型状态机的输出只与当前状态有关，与当前输入无关。

- 输出会在一个完整的时钟周期内保持稳定，即使此时输入信号有变化，输出也不会变化。输入对输出的影响要到下一个时钟周期才能反映出来。这也是 `Moore` 型状态机的一个重要特点：输入与输出是隔离开来的。

    ![img](http://nas.znmlr.cn:15900/markdown/2022/09/drIsJ2XFh6mt4t5D.png)

### 6.3.2 `Mealy` 型状态机

- `Mealy` 型状态机的输出，不仅与当前状态有关，还取决于当前的输入信号。

- `Mealy` 型状态机的输出是在输入信号变化以后立刻发生变化，且输入变化可能出现在任何状态的时钟周期内。因此，同种逻辑下，`Mealy` 型状态机输出对输入的响应会比 `Moore` 型状态机早一个时钟周期。

    ![img](http://nas.znmlr.cn:15900/markdown/2022/09/4xc5VfpojsJMoZX5.png)
