---
title: "02 基本语法"
date: 2022-09-27T16:28:25+08:00
draft: false
weight: 2
---

## 2.1 基础语法

- 区分大小写
- 格式自由，可以在一行，也可以跨行
- 每个语句必须以分号为结束符
- 注释有单行注释`//`和跨行注释`/*  */`

- 标识符可以是字母、数字、`$`和`_`，但只能字母或者`_`开头，标识符区分大小写
- `Verilog`中关键字全部是小写

## 2.2 `Verilog`数值表示

### 2.2.1 数值种类

- 四种基本值来表示硬件电路中的电平逻辑：

- `0`：逻辑`0`或者`假`
- `1`：逻辑`1`或者`真`
- `x`或者`X`：未知，意味着信号数值不确定，即实际信号可能是`1`，也可能是`0`
- `z`或者`Z`：高阻，常见于信号没有驱动时的逻辑结果

### 2.2.2 整数数值表示方法

- 数字声明时，合法的基数格式有`4`中，包括：十进制(`'d` 或` 'D`)，十六进制(`'h` 或 `'H`)，二进制（`'b` 或` 'B`），八进制（`'o` 或`'O`）。数值可指明位宽，也可不指明位宽。

```verilog
4'b1011         // 4bit 数值
32'h3022_c0de   // 32bit 的数值，下划线 _ 是为了增强代码的可读性。

// 一般直接写数字时，默认为十进制表示，例如下面的 3 种写法是等效的：
counter = 'd100 ; 	//一般会根据编译器自动分频位宽，常见的为32bit
counter = 100 ;
counter = 32'h64 ;

// 通常在表示位宽的数字前面加一个减号来表示负数。例如：
-6'd15  
-15
4'd-2 //非法说明
```

### 2.2.3 实数表示方法

```verilog
// 十进制
30.123
6.0
3.0
0.001

// 科学计数法
1.2e4         //大小为12000
1_0001e4      //大小为100010000
1E-3          //大小为0.001
```

### 2.2.4 字符串表示方法

- 字符串是由双引号包起来的字符队列。字符串不能多行书写，即字符串中不能包含回车符。`Verilog` 将字符串当做一系列的单字节 `ASCII` 字符队列。例如，为存储字符串 `www.runoob.com`, 需要 `14*8bit` 的存储单元。例如：

```verilog
reg [0: 14*8-1]       str ;
initial begin
    str = "www.runoob.com";
end  
```

## 2.3 `Verilog`数据类型

- `Verilog` 最常用的 `2` 种数据类型就是线网`wire`与寄存器`reg`，其余类型可以理解为这两种数据类型的扩展或辅助。

### 2.3.1 线网

- `wire`类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 `wire` 型变量，缺省值一般为 `Z`。举例如下：

```verilog
wire   interrupt ;
wire   flag1, flag2 ;
wire   gnd = 1'b0 ;  
```

- 线网型还有其他数据类型，包括 `wand`，`wor`，`wri`，`triand`，`trior`，`trireg` 等。这些数据类型用的频率不是很高，这里不做介绍。

### 2.3.2 寄存器

- 寄存器`reg`用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下：

```verilog
reg    clk_temp;
reg    flag1, flag2 ;
```

- 例如在`always`块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 `wire` 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如：

```verilog
reg rstn ;
initial begin
    rstn = 1'b0 ;
    #100 ;
    rstn = 1'b1 ;
end
```

### 2.3.3 向量

- 当位宽大于 `1` 时，`wire` 或 `reg` 即可声明为向量的形式。例如：

```verilog
reg [3:0]      counter ;    //声明4bit位宽的寄存器counter
wire [32-1:0]  gpio_data;   //声明32bit位宽的线型变量gpio_data
wire [8:2]     addr ;       //声明7bit位宽的线型变量addr，位宽范围为8:2
reg [0:31]     data ;       //声明32bit位宽的寄存器变量data, 最高有效位为0

```

- `Verillog` 还支持指定 `bit` 位后固定位宽的向量域选择访问。

```verilog
//下面 2 种赋值是等效的
A = data1[31-: 8] ;
A = data1[31:24] ;

//下面 2 种赋值是等效的
B = data1[0+ : 8] ;
B = data1[0:7] ;
```

- 对信号重新进行组合成新的向量时，需要借助大括号。例如：

```verilog
wire [31:0]    temp1, temp2 ;
assign temp1 = {byte1[0][7:0], data1[31:8]};  //数据拼接
assign temp2 = {32{1'b0}};  //赋值32位的数值0  
```

### 2.3.4 整数、实数、时间、寄存器变量

- 整数类型用关键字 `integer` 来声明。声明时不用指明位宽，位宽和编译器有关，一般为`32 bit`。`reg` 型变量为无符号数，而 `integer` 型变量为有符号数。例如：

```verilog
reg [31:0]      data1 ;
reg [3:0]       byte1 [7:0]; //数组变量，后续介绍
integer j ;  //整型变量，用来辅助生成数字电路
always@* begin
    for (j=0; j<=3;j=j+1) begin
        byte1[j] = data1[(j+1)*8-1 : j*8];
        //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]
        end
end
/*
此例中，integer 信号 j 作为辅助信号，将 data1 的数据依次赋值给数组 byte1。综合后实际电路里并没有 j 这个信号，j 只是辅助生成相应的硬件电路。
*/
```

- 实数用关键字 `real` 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 `0`。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。例如：

```verilog
real        data1 ;
integer     temp ;
initial begin
    data1 = 2e3 ;
    data1 = 3.75 ;
end
 
initial begin
    temp = data1 ; //temp 值的大小为3
end
```

- `Verilog` 使用特殊的时间寄存器 `time` 型变量，对仿真时间进行保存。其宽度一般为 `64 bit`，通过调用系统函数 `$time` 获取当前仿真时间。例如：

```verilog
time       current_time ;
initial begin
       #100 ;
       current_time = $time ; //current_time 的大小为 100
end
```

- 在 `Verilog` 中允许声明 `reg`,`wire`, `integer`, `time`, `real` 及其向量类型的数组。
- 数组维数没有限制。线网数组也可以用于连接实例模块的端口。
- 数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如：**<数组名>[<下标>]**。
- 对于多维数组来讲，用户需要说明其每一维的索引。例如：

```verilog
integer          flag [7:0] ; //8个整数组成的数组
reg  [3:0]       counter [3:0] ; //由4个4bit计数器组成的数组
wire [7:0]       addr_bus [3:0] ; //由4个8bit wire型变量组成的数组
wire             data_bit[7:0][5:0] ; //声明1bit wire型变量的二维数组
reg [31:0]       data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组

flag [1]   = 32'd0 ; //将flag数组中第二个元素赋值为32bit的0值
counter[3] = 4'hF ;  //将数组counter中第4个元素的值赋值为4bit 十六进制数F，等效于counter[3][3:0] = 4'hF，即可省略宽度;
assign addr_bus[0]        = 8'b0 ; //将数组addr_bus中第一个元素的值赋值为0
assign data_bit[0][1]     = 1'b1;  //将数组data_bit的第1行第2列的元素赋值为1，这里不能省略第二个访问标号，即 assign data_bit[0] = 1'b1; 是非法的。
data_4d[0][0][0][0][15:0] = 15'd3 ;  //将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3
```

- 虽然数组与向量的访问方式在一定程度上类似，但不要将向量和数组混淆。向量是一个单独的元件，位宽为 `n`；数组由多个元件组成，其中每个元件的位宽为 `n` 或 `1`。它们在结构的定义上就有所区别。
- 存储器变量就是一种寄存器数组，可用来描述 `RAM` 或 `ROM` 的行为。例如：

```verilog
reg               membit[0:255] ;  //256bit的1bit存储器
reg  [7:0]        mem[0:1023] ;    //1Kbyte存储器，位宽8bit
mem[511] = 8'b0 ;                  //令第512个8bit的存储单元值为0
```

- 参数用来表示常量，用关键字 `parameter` 声明，只能赋值一次。例如：

```verilog
parameter      data_width = 10'd32 ;
parameter      i=1, j=2, k=3 ;
parameter      mem_size = data_width * 10 ;
```

- 但是，通过实例化的方式，可以更改参数在模块中的值。此部分以后会介绍。

- 局部参数用 `localparam` 来声明，其作用和用法与 `parameter` 相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用 `localparam` 来说明。
- 字符串保存在 `reg` 类型的变量中，每个字符占用一个字节`8bit`。因此寄存器变量的宽度应该足够大，以保证不会溢出。
- 字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 `0` 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 `run.runoob.com`, 需要 `14*8bit` 的存储单元：

```verilog
reg [0: 14*8-1]       str ;
initial begin
    str = "run.runoob.com";
end  
```

## 2.4 `Verilog`表达式

- 表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。
- 操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。

```verilog
module test;

//实数
real a, b, c;
c = a + b ;

//寄存器
reg  [3:0]       cprmu_1, cprmu_2 ;
always @(posedge clk) begin
        cprmu_2 = cprmu_1 ^ cprmu_2 ;
end
         
//函数
reg  flag1 ;
flag = calculate_result(A, B);
 
//非法操作数
reg [3:0]         res;
wire [3:0]        temp;
always@ （*）begin
    res    = cprmu_2 – cprmu_1 ;
    //temp = cprmu_2 – cprmu_1 ; //不合法，always块里赋值对象不能是wire型
end

endmodule
```

- `Verilog` 中提供了大约 `9` 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。
- 大部分操作符与 `C` 语言中类似。同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。例如下面每组的 `2` 种写法都是等价的。

```verilog
//自右向左关联，两种写法等价
A+B-C ;
(A+B）-C ;

//自右向左关联，两种写法等价，结果为 B、D 或 F
A ? B : C ? D : F ;
A ? B : (C ? D : F) ;

//自右向左关联，两种写法不等价
(A ? B : C) ? D : F ;  //结果 D 或 F
A ? B : C ? D : F ; //结果为 B、D 或 F
```

| 操作符       | 操作符号                     | 优先级 |
| :----------- | :--------------------------- | :----- |
| 单目运算     | `+` 、`-` 、`!` 、`~`        | 最高   |
| 乘、除、取模 | `*`、 `/`、 `%`              |        |
| 加减         | `+` 、`-`                    |        |
| 移位         | `<<`、  `>>`                 |        |
| 关系         | `<` 、`<=` 、`>` 、`>=`      |        |
| 等价         | `==` 、`!=` 、`===` 、`!===` |        |
| 归约         | `&` 、`~&`                   |        |
|              | `^` 、`~^`                   |        |
|              | `|` 、`~|`                   |        |
| 逻辑         | `&&`                         |        |
|              | `||`                         |        |
| 条件         | `?:`                         | 最低   |

### 2.4.1 算术操作符

- 算术操作符包括单目操作符和双目操作符。
- 双目操作符对 `2` 个操作数进行算术运算，包括乘`*`、除`/`、加`+`、减`-`、求幂`**`、取模`%`。

```verilog
reg [3:0]  a, b;
reg [4:0]  c ;
a = 4'b0010 ;
b = 4'b1001 ;
c = a+b;        //结果为c=b'b1011
c = a/b;          //结果为c=4，取整

// 如果操作数某一位为 X，则计算结果也会全部出现 X。例如：
b = 4'b100x ;
c = a+b ;       //结果为c=4'bxxxx
```

### 2.4.2 关系操作符

- 关系操作符有大于`>`，小于`<`，大于等于`>=`，小于等于`<=`。
- 关系操作符的正常结果有 `2` 种，真`1`或假`0`。
- 如果操作数中有一位为 `x` 或`z`，则关系表达式的结果为 `x`。

```verilog
A = 4 ;
B = 3 ;
X = 3'b1xx ;
   
A > B     //为真
A <= B    //为假
A >= Z    //为X，不确定
```

### 2.4.3 等价操作符

- 等价操作符包括逻辑相等`==`，逻辑不等`!=`，全等`===`，非全等`!==`。

- 等价操作符的正常结果有 `2` 种，真`1`或假`0`。

- 逻辑相等/不等操作符不能比较 `x` 或 `z`，当操作数包含一个 `x` 或 `z`，则结果为不确定值。

- 全等比较时，如果按位比较有相同的 `x` 或 `z`，返回结果也可以为 `1`，即全等比较可比较 `x` 或 `z`。所以，全等比较的结果一定不包含 `x`。举例如下：

```verilog
A = 4 ;
B = 8'h04 ;
C = 4'bxxxx ;
D = 4'hx ;
A == B        //为真
A == (B + 1)  //为假
A == C        //为X，不确定
A === C       //为假，返回值为0
C === D       //为真，返回值为1
```

### 2.4.4 逻辑操作符

- 逻辑操作符主要有 `3` 个：`&&`（逻辑与）, `||`（逻辑或），`!`（逻辑非）。

- 逻辑操作符的计算结果是一个 `1bit` 的值，`0` 表示假，`1` 表示真，`x` 表示不确定。

- 如果一个操作数不为 `0`，它等价于逻辑 `1`；如果一个操作数等于 `0`，它等价于逻辑 `0`。如果它任意一位为 `x` 或 `z`，它等价于 `x`。

- 如果任意一个操作数包含 `x`，逻辑操作符运算结果不一定为 `x`。

- 逻辑操作符的操作数可以为变量，也可以为表达式。例如：

```verilog
A = 3;
B = 0;
C = 2'b1x ;
   
A && B    //     为假
A || B    //     为真
! A       //     为假
! B       //     为真
A && C    //     为X，不确定
A || C    //     为真，因为A为真
(A==2) && (! B)  //为真，此时第一个操作数为表达式
```

### 2.4.5 按位操作符

- 按位操作符包括：取反`~`，与`&`，或`|`，异或`^`，同或`~^`。

- 按位操作符对 `2` 个操作数的每 `1bit` 数据进行按位操作。

- 如果 `2` 个操作数位宽不相等，则用 `0` 向左扩展补充较短的操作数。

- 取反操作符只有一个操作数，它对操作数的每 `1bit` 数据进行取反操作。

  ![Snipaste_2022-09-17_11-06-54](http://nas.znmlr.cn:15900/markdown/2022/09/Snipaste_2022-09-17_11-06-54.png)

### 2.4.6 归约操作符

- 归约操作符包括：归约与`&`，归约与非`~&`，归约或`|`，归约或非`~|`，归约异或`^`，归约同或`~^`。

- 归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 `1bit` 结果。

- 逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。

```verilog
A = 4'b1010 ;
&A ;      //结果为 1 & 0 & 1 & 0 = 1'b0，可用来判断变量A是否全1
~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1'b0, 可用来判断变量A是否为全0
^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1'b0
```

### 2.4.7 移位操作符

- 移位操作符包括左移`<<`，右移`>>`，算术左移`<<<`，算术右移`>>>`。

- 移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。

- 算术左移和逻辑左移时，右边低位会补 `0`。

- 逻辑右移时，左边高位会补 `0`；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。

```verilog
A = 4'b1100 ;
B = 4'b0010 ;
A = A >> 2 ;        //结果为 4'b0011
A = A << 1;         //结果为 4'b1000
A = A <<< 1 ;       //结果为 4'b1000
C = B + (A>>>2);    //结果为 2 + (-4/4) = 1, 4'b0001
```

### 2.4.8 拼接操作符

- 拼接操作符用大括号 `{，}` 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。

- 拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：

```verilog
A = 4'b1010 ;
B = 1'b1 ;
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
```

### 2.4.9 条件操作符

- 略

## 2.5 `Verilog` 编译指令

- 以反引号**\`** 开始的某些标识符是 `Verilog` 系统编译指令。

- 编译指令为 `Verilog` 代码的撰写、编译、调试等提供了极大的便利。

### 2.5.1 **\`define**, **\`undef**

- 在编译阶段，**\`define** 用于文本替换，类似于 `C` 语言中的 **#define**。

- **\`undef** 用来取消之前的宏定义

### 2.5.2 **\`ifdef**、**\`elsif**、**\`else**、**\`endif**、**\`ifndef**

```verilog
// 这些属于条件编译指令。例如下面的例子中，如果定义了 MCU51，则使用第一种参数说明；如果没有定义 MCU、定义了 WINDOW，则使用第二种参数说明；如果 2 个都没有定义，则使用第三种参数说明。

`ifdef       MCU51
    parameter DATA_DW = 8   ;
`elsif       WINDOW
    parameter DATA_DW = 64  ;
`else
    parameter DATA_DW = 32  ;
`endif
```

### 2.5.3 **\`include**

- 可以在编译时将一个 `Verilog` 文件内嵌到另一个 `Verilog` 文件中，作用类似于 `C` 语言中的 `#include` 结构。该指令通常用于将全局或公用的头文件包含在设计文件里。

- 文件路径既可以使用相对路径，也可以使用绝对路径。

### 2.5.4 **\`timescale**

- 在 Verilog 模型中，时延有具体的单位时间表述，并用 **`timescale** 编译指令将时间单位与实际时间相关联。

- 该指令用于定义时延、仿真的单位和精度，格式为：

- `time_unit` 表示时间单位，`time_precision` 表示时间精度，它们均是由数字以及单位 `s`（秒），`ms`（毫秒），`us`（微妙），`ns`（纳秒），`ps`（皮秒）和 `fs`（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 `Z` 会延迟 `5.21ns` 输出 `A&B` 的结果。

```verilog
`timescale      time_unit / time_precision


`timescale 1ns/100ps    //时间单位为1ns，精度为100ps，合法
//`timescale 100ps/1ns  //不合法
module AndFunc(Z, A, B);
    output Z;
    input A, B ;
    assign #5.207 Z = A & B
endmodule
```

- 在编译过程中，**\`timescale** 指令会影响后面所有模块中的时延值，直至遇到另一个 **\`timescale** 指令或 **\`resetall** 指令。

- 由于在 `Verilog` 中没有默认的 **``timescale**，如果没有指定 **``timescale**，`Verilog` 模块就有会继承前面编译模块的 **``timescale** 参数。有可能导致设计出错。

- 如果一个设计中的多个模块都带有 **``timescale** 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度，时延单位并不受影响。

### 2.5.5 **\`default_nettype**

- 该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。

```verilog
//Z1 无定义就使用，系统默认Z1为wire型变量，有 Warning 无 Error
module test_and(
        input      A,
        input      B,
        output     Z);
    assign Z1 = A & B ;  
endmodule

//Z1无定义就使用，由于编译指令的存在，系统会报Error，从而检查出书写错误
`default_nettype none
module test_and(
        input      A,
        input      B,
        output     Z);
    assign Z1 = A & B ;  
endmodule
```
